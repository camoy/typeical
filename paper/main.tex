% $Id: template.tex 11 2007-04-03 22:25:53Z jpeltier $

%\documentclass{vgtc}                          % final (conference style)
\documentclass[review]{vgtc}                 % review
%\documentclass[widereview]{vgtc}             % wide-spaced review
%\documentclass[preprint]{vgtc}               % preprint
%\documentclass[electronic]{vgtc}             % electronic version

%% Uncomment one of the lines above depending on where your paper is
%% in the conference process. ``review'' and ``widereview'' are for review
%% submission, ``preprint'' is for pre-publication, and the final version
%% doesn't use a specific qualifier. Further, ``electronic'' includes
%% hyperreferences for more convenient online viewing.

%% Please use one of the ``review'' options in combination with the
%% assigned online id (see below) ONLY if your paper uses a double blind
%% review process. Some conferences, like IEEE Vis and InfoVis, have NOT
%% in the past.

%% Figures should be in CMYK or Grey scale format, otherwise, colour
%% shifting may occur during the printing process.

%% These few lines make a distinction between latex and pdflatex calls and they
%% bring in essential packages for graphics and font handling.
%% Note that due to the \DeclareGraphicsExtensions{} call it is no longer necessary
%% to provide the the path and extension of a graphics file:
%% \includegraphics{diamondrule} is completely sufficient.
%%
\ifpdf%                                % if we use pdflatex
  \pdfoutput=1\relax                   % create PDFs from pdfLaTeX
  \pdfcompresslevel=9                  % PDF Compression
  \pdfoptionpdfminorversion=7          % create PDF 1.7
  \ExecuteOptions{pdftex}
  \usepackage{graphicx}                % allow us to embed graphics files
  \DeclareGraphicsExtensions{.pdf,.png,.jpg,.jpeg} % for pdflatex we expect .pdf, .png, or .jpg files
\else%                                 % else we use pure latex
  \ExecuteOptions{dvips}
  \usepackage{graphicx}                % allow us to embed graphics files
  \DeclareGraphicsExtensions{.eps}     % for pure latex we expect eps files
\fi%

%% it is recomended to use ``\autoref{sec:bla}'' instead of ``Fig.~\ref{sec:bla}''
\graphicspath{{figures/}{pictures/}{images/}{./}} % where to search for the images

\usepackage{microtype}                 % use micro-typography (slightly more compact, better to read)
\PassOptionsToPackage{warn}{textcomp}  % to address font issues with \textrightarrow
\usepackage{textcomp}                  % use better special symbols
\usepackage{mathptmx}                  % use matching math font
\usepackage{times}                     % we use Times as the main font
\renewcommand*\ttdefault{txtt}         % a nicer typewriter font
\usepackage{cite}                      % needed to automatically sort the references
\usepackage{tabu}                      % only used for the table example
\usepackage{booktabs}                  % only used for the table example
%% We encourage the use of mathptmx for consistent usage of times font
%% throughout the proceedings. However, if you encounter conflicts
%% with other math-related packages, you may want to disable it.

\usepackage{xspace}

\usepackage{caption}
\captionsetup[table]{skip=10pt}
\usepackage{tabularx}
\usepackage{todonotes} %TODO: Remove after all TODO's are gone
\usepackage{lineno}
\linenumbers

%% ===================================== Commands
\newcommand{\code}[1]{\texttt{\small{#1}}}
\newcommand{\typevis}{{\sc TypeVis}\xspace}
\newcommand{\figref}[1]{Figure~\ref{#1}\xspace}
\newcommand{\pkgNumAnalyzed}{412\xspace}
\newcommand{\settingsTab}{{\sc Settings}\xspace}

%% If you are submitting a paper to a conference for review with a double
%% blind reviewing process, please replace the value ``0'' below with your
%% OnlineID. Otherwise, you may safely leave it at ``0''.
\onlineid{0}

%% declare the category of your paper, only shown in review mode
\vgtccategory{Research}

%% allow for this line if you want the electronic option to work properly
\vgtcinsertpkg

%% In preprint mode you may define your own headline.
%\preprinttext{To appear in an IEEE VGTC sponsored conference.}

\title{Type Visualization for R}

\author{Cameron Moy\thanks{camoy@ccs.neu.edu}
\and Julia Belyakova\thanks{belyakovay@ccs.neu.edu}}
\affiliation{\scriptsize Northeastern University}

\abstract{
  Data-driven approaches to programming language design are uncommon.
  Despite the availability of large code repositories, distilling useful
  information from programs remains difficult. Important dimensions,
  like run-time type data, are inscrutable without the appropriate tools.
  \typevis is an interactive visualization for exploring and analyzing
  type information from program execution traces---aiding
  user understanding of function type signatures across many executions.
  The system uses flows to intuitively represent categorical
  and numerical aspects of type signatures.
  Insights derived from our visualization are aimed at informing
  language design decisions---specifically of a new gradual type system
  currently being developed for the R programming language.
}

%% ACM Computing Classification System (CCS).
%% See <http://www.acm.org/about/class> for details.
%% We recommend the 2012 system <http://www.acm.org/about/class/class/2012>
%% For the 2012 system use the ``\CCScatTwelve'' which command takes four arguments.
%% The 1998 system <http://www.acm.org/about/class/class/2012> is still possible
%% For the 1998 system use the ``\CCScat'' which command takes four arguments.
%% In both cases the last two arguments (1998) or last three (2012) can be empty.

\CCScatlist{
  \CCScatTwelve{Human-centered computing}{Visualization}{Visualization systems and tools}{}
}

%% Copyright space is enabled by default as required by guidelines.
%% It is disabled by the 'review' option or via the following command:
% \nocopyrightspace

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%% START OF THE PAPER %%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\firstsection{Introduction}

\maketitle

Programming languages commonly evolve by decree. Often, the language designer
decides that a new feature is necessary, or that a past feature was
ill-conceived. Thus, the language moves forward---
forcing its users to adapt to the changes.
Sometimes, these changes are the result of rigorous theory
or the product of community feedback. However, rarely is language design
informed by empirical data on how programs are \emph{actually
written} in practice. Why so?

%For a popular language, data collection is no challenge. Vast
Thanks to the prevalence of open source code, collecting data on
the usage of a popular programming language is feasible. Vast
quantities of publicly available code are hosted on repositories such as Github.
Furthermore, if there is concern about the quality of this data,
such as code duplication~\cite{lopes:2017},
code can be obtained from curated
language-specific package repositories like npm or CRAN.

To inform programming language design,
the collected data needs to be analyzed and interpreted.
Programs are complex and highly structured,
so simple semantically-ignorant metrics like ``lines of code'' carry little significance.
Therefore, researchers often employ static and dynamic analyses
to gather information about specific aspects of programs.
Even then, it may be difficult to make sense of the
results of these analyses,
especially if the data set is large.
%Rather, the difficulty lies with analyzing and interpreting the data
%at hand. Code is complex and highly structured. Simple

To analyze just one aspect of programming languages, \emph{type usage}, we
built \typevis, an interactive visualization of run-time type signatures.
%an interactive visualization of run-time types for the language R.
\typevis was created with the R programming language in mind,
and builds on a data set of execution traces
mined from the unit tests and vignettes
of the most widely used libraries in the R ecosystem.

The tool supports three broad tasks:
\begin{itemize}
  \setlength\itemsep{0em}
  \item filtering the data set down to an amenable subset;
  \item understanding the types of function arguments and returns;
  \item comparing type signatures across different functions.
\end{itemize}
%For filtering, \typevis uses the treemap idiom
%to convey the relative scale of different packages.
For exploring and filtering the data set,
\typevis relies on treemaps to represent R packages and functions,
with node size conveying relative popularity.
Additionally, one can search directly for a function by name.
Once a subset of one or more functions is selected,
their type signatures are encoded as flows over types,
where flow width is proportional to frequency.
These flows can be readily compared within the same function,
or between different functions.

\typevis can assist language designers during multiple phases of development.
For example, exploratory data analysis can identify unexpected edge cases,
or weed out language designs that are incompatible with existing programs.
\typevis was built in support of a new gradual type system for R,
whose adoption depends on integrating well with existing code.
However, the visualization is not limited to R and can be used to
analyze type usage in any language where similar data are available.

Supplemental material, including the data and source code of
\typevis, is freely available: \todo{Add archival link}

\bgroup
\def\arraystretch{1.75}
\begin{table*}
  \centering
  \begin{tabularx}{\linewidth}{c|c|c|X}
    Domain Goals & Search Task & Query Task & \multicolumn{1}{c}{Abstract Task Description} \\
    \hline
    Find Function & Locate & Identify & Finding a function is a location task, where the target function is known, but its location within the package hierarchy is not. Once the desired function is found, a user must be able to identify data of interest. \\

    Determine Types & Browse & Identify & Determining types is a browse task, where the target type signature is unknown, but the location of the function of interest is known. While browsing, a user must be able to identify the frequencies of particular type signatures.\\

    Compare Signatures & Lookup & Compare & Comparing type signatures is a lookup task where both target type signatures have already been located. A user must be able to discern how often a signature is used compared to another, both within a function and across different functions.\\
  \end{tabularx}
  \caption{Domain goals and their mid-level and low-level task abstractions.}
  \label{tab:tasks}
\end{table*}
\egroup

%%

\section{Background and Prior Work}

R is a lazy, multi-paradigm, dynamically-typed programming language
widely used for statistical computing~\cite{morandat:2012}.
Unlike statically-typed languages,
R code contains no type annotations
and never passes through a typechecker.
At run-time,
functions may be called with values of arbitrary type,
and may return values of arbitrary type.\footnote{
  We use the word ``type'' to mean what others may call a ``type tag.''
  This is a run-time concept---we do not assume a static type system
  because there is none. Indeed, the goal is to help design one!
  A ``type signature'' in this context is one particular configuration
  of argument and return types a function is called with at run-time.
}

Being a dynamically-typed language
with widespread use in a single domain,
R is a good target for a gradual type system.
A gradual type system permits the integration of
static and dynamic typing~\cite{siek:2006,tobin-hochstadt:2006},
and is capable of seamlessly mixing typed and untyped regions of code.

For statically-typed languages, the type system is usually
an inseparable part of the language. Since they are designed
at the same time, the type system precedes any code written
in the language.
Gradual type systems, by contrast, are often designed atop
an existing dynamically-typed language~\cite{tobin-hochstadt:2016}.
Many R programs already exist,
so a successful gradual type system must
work well with extant code.

We are not aware of any previous work that applies
visualization techniques for the purpose of programming language design.
However, there are existing publications on understanding
software through visualization.
Bohnet et al.~\cite{bohnet:2009} visualize massive program execution traces
to improve developer comprehension of large software systems.
Their tool applies pruning and summarization techniques to reduce trace size.
They focus on call topology,
describing the structure of function invocations,
rather than types.
Telea et al.~\cite{telea:2009} also develop a methodology for displaying call structure.
However, they visualize call graphs of systems in their entirety,
rather than individual execution traces.
\typevis has elements of both,
investigating the system as a whole,
but doing so via execution traces.
In addition to standard call graphs,
LaToza and Myers~\cite{latoza:2011} adorn nodes and edges with extra information,
allowing the user to gain further understanding of the system
under examination.
This includes grouping methods that come from the same class---a
basic form of type data.

%%

\section{Data and Collection} \label{sec:data}

The data set we used comes from
Turcotte et al.~\cite{turcotte:2020}
and consists of traces from \pkgNumAnalyzed packages,
containing over $760,000$ lines of R code
and $534,000$ lines of native code.
All libraries were obtained from CRAN,
the most popular R code repository.
Packages hosted on CRAN are curated and satisfy
certain quality standards.
Out of the over $15,000$ packages
distributed on CRAN,
the subset of 412 packages considered here
all had code coverage above 65\%.
\todo{Confirm with Alexi this paragraph. Get proper BibTeX entry.}

Execution traces were recorded by running a dynamic analysis
over the test, example, and vignette code of each package.
A vignette is a form of documentation that weaves
together prose and executable code.
An execution trace is a list of function type signatures
containing, among other attributes, the function name
and type tags for each argument and return value.
For example, the function call {\tt !(FALSE)}
would be recorded as the type signature {\tt logical $\to$ logical},
meaning that the function {\tt !} took a logical value (i.e. a boolean)
and returned a logical value.
The type tags are assigned by the dynamic analysis
and refine the actual type tags at run-time.
For instance, the analysis
assigns the scalar tag {\tt double} to a singleton vector of double values
because R does not have native support for scalars.
The data set is a table of reduced execution traces.
Because \typevis was designed for the analysis of types,
not all information in the traces is relevant.
%that have been processed to reduce some fields.
%Traces were generated via a dynamic analysis
%that instruments the R virtual machine with hooks
%that intercept the required data at run-time.

While \typevis has only been instantiated with
data from R execution traces, the architecture is not limited to R.
Any dynamically-typed language, %with the right run-time
%hooks could generate data for the tool.
or statically-typed language with run-time tag information,
could be instrumented to generate data for the tool.
As long as the trace output adheres to
the correct schema, \typevis will work properly without any modifications.

%%

\section{Task Abstraction}

We interviewed the primary researcher developing a gradual type system for R
to inventory relevant domain-specific tasks.
Additionally, we sought his and other researchers' feedback
throughout the creation of \typevis
to ensure it was adequately meeting requirements.
The domain-specific goals identified were:

\begin{enumerate}
\item {\bf Find Function.} Quickly search for a particular function and identify basic information. This includes how often the function is called and which package contains it.
\item {\bf Determine Types.} Given a specific function,
  determine its argument and return types, and identify the frequency of specific type signatures.
  A user should be able to readily infer, for example,
  if a function is polymorphic (i.e. accepts arguments of multiple different types) or if it is a predicate (i.e. returns a logical value).
\item {\bf Compare Signatures.} Compare the occurrence of type signatures within a specific function, and across many different functions. A user must be able to isolate individual signatures and exmaine them in the context of others.
\end{enumerate}

These goals can be classified using an abstract task analysis framework.
See table~\ref{tab:tasks} for a categorization of these domain tasks
with the mid-level and low-level abstract task taxonomy
established by Brehmer and Munzner~\cite{brehmer:2013}.

%%

\section{Design and Implementation}

\begin{figure*}
 \centering
 \includegraphics[width=\linewidth]{img/typevis.png}
 \caption{The main view of \typevis, with type flows on the left and the package hierarchy on the right. Here, the {\tt length.unit} and {\tt valid.unit} functions from the {\tt grid} package are both selected and displayed simultaneously.}
 \label{fig:typevis}
\end{figure*}

\typevis is an interactive web-based visualization
that permits real-time data exploration,
even with large data sets.
The default data set of R execution traces,
described in \S\ref{sec:data},
contains over a million rows.

\figref{fig:typevis} shows
the heart of \typevis---the type flow panel on the left
and the function filtering panel on the right.
Type signatures shown on the left reflect
the subset of the data selected on the right.
By default, if no subset is selected, the type flow
panel shows several of the most frequent function type signatures
in the entire data set.
%in its initial configuration.
Various aspects of the system,
such as the number of type signatures shown at once,
can be tweaked by the user if desired;
for this, a separate \settingsTab tab is provided.

\subsection{Function Filtering}

The right-hand panel of \figref{fig:typevis}
contains three elements: a search bar,
a package treemap,
and a function treemap.
All three components are linked.
Selecting a package
in the top treemap causes the bottom treemap
to show only functions defined in that package;
additionally, the type flow panel gets updated
with the most frequent function type signatures in the package.
Selecting a function in the bottom treemap
makes the type flow panel show only signatures
of that function.
Entering a function name in the search bar
updates the type flow panel immediately.

These different components support at least two modes
of search: quick function lookup and package exploration.
If a user has a specific function in mind,
they can type its name into the search bar and see its
type signatures straight away;
the search bar supports autocomplete that is
able to select one function among thousands.
If, on the other hand, one wants to browse
all available packages and functions,
the treemap view is more applicable.
The area of a block in the function treemap (package treemap)
conveys the log-scaled
frequency of calls to that function
(to all functions defined in that package).
%Area in the bottom treemap conveys the log-scaled
%frequency of function calls,
%and correspondingly the top treemap
%is scaled based on invocations
%of functions defined in that package.
Log-scaling and pagination keep
elements of the treemaps legible,
even when absolute size differences are significant.

The data set can additionally be filtered by analyzed package,
in other words, the package containing the call site of a function, not the definition site.
As mentioned in \S\ref{sec:data}, the data set contains information
from \pkgNumAnalyzed analyzed packages, which are all taken into account
by default. However, a user can limit the set of analyzed packages,
using a search bar in \settingsTab.

Although treemaps are often used for displaying
hierarchical data~\cite{shneiderman:1992},
in \typevis they have a flat structure.
The packages in our data are not deeply structured,
so the treemaps in \figref{fig:typevis} are only one level deep.
However, in many programming languages, like Java,
package systems contain deeply nested namespace hierarchies.
The treemap idiom is appropriate for navigation of such
hierarchies, and
%However, if the data set recorded deeply nested packages,
\typevis could be modified to handle that.

By default, \typevis allows only one function to be selected at a time,
but it can be configured for multiple function selection.
In the example from \figref{fig:typevis},
the {\tt length.unit} and {\tt valid.unit} functions
from the {\tt grid} package are both selected.
These functions are rendered simultaneously in the type flow
panel, allowing the user to make comparisons between them.
However, if the user wants to explore different functions rather than
compare them, the default one-function mode is more appropriate.

\subsection{Types as Flows}

Prominently featured in the center of \figref{fig:typevis}
is a parallel sets diagram encoding the type signatures of the selected
functions as flows.
Parallel sets,
proposed by Kosara et al.~\cite{kosara:2006},
are ideally suited for type signatures.
Each data point can be thought of as
a tuple $(f, \tau_1, \ldots, \tau_n, \tau_r)$
corresponding to the function name,
argument types,
and return type.
Every component of that tuple is categorical,
and we are interested in visualizing the frequencies of these points.
This is the exact use-case for parallel sets.

Flows begin at a node labeling a function,
curve across each argument type in order,
and terminate at the return type.
Widths are proportional to how many times a function
is called with that signature during analysis.
Flow segments are filled with a hue-varying color scale,
determined by the type where the segment ends.
Beneath each node label is an approximate count of either:
how many times the function was invoked if the node represents a function,
or how often a value of that type was recorded during analysis if the node represents a type.

In \figref{fig:typevis},
the {\tt length.unit} function is called with
two different type signatures at run-time.
Most frequently, the function is used with the
signature {\tt double $\to$ integer},
but a substantial fraction of the time it is
used as {\tt double[] $\to$ integer}.
Here, {\tt double[]} stands for an array of
doubles with arbitrary dimension.

Interactivity significantly enhances the
usability of the parallel sets diagram.
Hovering over a flow will highlight the
entire path of the flow
and will fade out all other functions,
as shown in \figref{fig:typevis}.
When displaying many flows at the same time,
highlighting becomes critical
for user comprehension.
Additional quantitative information
about the flow is supplied on-demand while hovering.
Clicking a flow will focus on that function
only, filtering away all others;
double clicking outside flows will bring back the previous view.
The number of flows shown at a time is limited,
and will paginate if that threshold is exceeded.

Flow layout is a necessary consideration
for a legible visualization~\cite{sugiyama:1981}.
Figure~\ref{fig:decross} exemplifies what
happens if flow layout is not adequately computed.
The top layout was generated without any
flow decrossing algorithm,
while the bottom layout applies optimal decrossing.
Even with highlighting,
the top visualization is almost impossible to understand
due to excessive flow overlap.
To maintain real-time performance,
we use two different decrossing methods.
First, the system attempts to construct
a layout with the globally optimal solution,
minimizing the amount of flow crossing by
solving a mixed-integer linear program~\cite{ebner:2005}.
Unfortunately, for even moderately
sized graphs this can take too long to compute.
Therefore, after about $1$ second,
the optimal algorithm is terminated
if it has not finished, and the final layout is computed
by a faster
algorithm that only minimizes local crossing between layers.
%computes the layout.
While the resulting layout might not be ideal,
it is much better than the one without decrossing at all.

\subsection{Technical Details}

Since the amount of data a user may query is large,
the application is split into a frontend and a backend.
The backend is responsible for storing the data
and fetching required information from the underlying database.
The frontend serves as an interactive interface to the data
and provides the visualization.
This avoids excessive memory consumption and speeds up computations,
as the client queries data from the server on a need-to-know basis.

On the frontend, state management, interactivity,
and DOM manipulation is all done with the Vue framework.
This differs from many web-based visualizations
that use D3 for DOM manipulation.
We chose this setup because \typevis retains many distinct
components whose state must be kept synchronized.
This includes not only the visualizations, but also
user interface elements like the search bar.
In our experience, Vue's model of reactivity is
more successful at maintaining consistency across the
entire application than D3 and vanilla JavaScript.
While \typevis does not use D3 for DOM manipulation,
it still does use it for other visualization-related
tasks. Decrossing is computed using web workers
to allow early termination if the thread takes too long.

Our backend is a Node.js application that serves
JSON with a standard REST-style architecture.
Data is stored in a SQLite database that has been
indexed to achieve lookups as fast as possible.
A stable network connection is required for
real-time interaction.

\begin{figure}[tb]
 \centering
 \includegraphics[width=\columnwidth]{img/no_decross.png}
 \includegraphics[width=\columnwidth]{img/decross.png}
 \caption{Comparison of type flows without decrossing (above) and with decrossing (below).}
 \label{fig:decross}
\end{figure}

%%

\section{Limitations and Future Work}

Designed with a specific use case in mind,
\typevis suffers from some shortcomings
and does not fully address the entire range of tasks
a language designer may need to perform.

In particular, \typevis does not allow for exploring 
type information at differing granularities.
R supports a range of data types
including ones containing dimensionality information.
For example, an R array may have type {\tt integer[3]}
indicating that it is an array of length $3$.
Every such type will get compressed down %into a single array of
to a simpler array
type {\tt integer[]}.
Reducing the number of types can make the visualization
more understandable, at the expensive of losing
precision in type information.
Ideally, a user would be able to interactively tune
the level of granularity based on their interest.
Such a feature would be especially helpful for R,
because values can come attached with lots of relevant
data such as the dynamic dispatch method
or user-specified metadata.

Filtering is a central mechanism of our system,
but it also comes at a cost.
If one has a specific function or several functions
in mind, then \typevis provides a useful
local view of that information.
It does not support, however, any kind of global
view of type information across a large number of
functions. When the amount of flows or nodes
becomes too great, the visualization will start
paginating, making comparisons across all flows impossible.
Aggregation and summarization would be key to
making a global view of the data feasible, but that remains future work.

%%

\section{Conclusion}

We have presented \typevis, an interactive visualization
of run-time type information
that supports real-time analysis and exploration.
The tool was instantiated with a massive data set of
execution traces from a corpus of popular R packages.

\typevis provides facilities for filtering, searching,
understanding, and comparing type information.
Type signatures of function calls
are represented as flows traversing
each argument type and return type in sequence.
Quick function lookup is supported by a search bar,
with package and function treemaps facilitating
function exploration.
Various interactions provide additional details and
assist users with comprehension and navigation.

Our system is aimed at elucidating how R programmers
use the language in the field.
Specifically, the data and visualization will be used to
inform the design of a future gradual type system for R.
However, \typevis is not tied to the R ecosystem
and is suitable to use for any %dynamically-typed language.
language that supports run-time type information.
The visualization could yield insights
useful for purposes other than gradual typing,
and beyond what we have considered.

We hope that, in the future, programming language designers
will collect and use empirical data about their languages
more extensively.
Such data could be used to make informed decisions about design,
where the cost of making a mistake is high.
Visualization will be unavoidable in these scenarios
since semantically-meaning information about programs
is rich in structure.
Generic, canned visualizations will not be sufficient.
\typevis is a first step in this direction.

\acknowledgments{
  The authors wish to thank
  Alexi Turcotte,
  Cody Dunne,
  Sara Di Bartolomeo,
  Younes El Idrissi Yazami,
  Peta Maj,
  the students of CS 7250,
  and contributors to all the open source projects that \typevis uses.
  This work was supported in part by a Northeastern Graduate Fellowship.
}

\bibliographystyle{abbrv-doi}

\bibliography{main}
\end{document}